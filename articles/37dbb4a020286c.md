---
title: "`Layout()`ã§ã‚µã‚¤ã‚ºã‚’å¼·åˆ¶ã—ãŸTextãŒã¯ã¿å‡ºã‚‹å•é¡Œã‚’å¯¾å‡¦ã™ã‚‹"
emoji: "ğŸ« "
type: "tech"
topics:
- "android"
- "animation"
- "jetpackcompose"
  published: true
  published_at: "2024-11-25 18:44"
---

ä»¥å‰ä½œæˆã—ãŸè‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹textã§ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«é…ç½®ã™ã‚‹ã¨è¡¨ç¤ºç¯„å›²å¤–ã§ã‚‚textãŒè¡¨ç¤ºã•ã‚Œã¦ã—ã¾ã†å•é¡ŒãŒã‚ã£ãŸã€‚
ä»¥å‰ã®è¨˜äº‹â†“
https://zenn.dev/matuyuhi/articles/403eb513881176

æ“¬ä¼¼çš„ãªå†ç¾ã®`Preview`
```kotlin
@Preview
@Composable
private fun AutoScrollTextPreview() {
    Box(
        modifier = Modifier
            .width(300.dp)
            .background(Color.Gray),
        contentAlignment = Alignment.Center
    ) {
        Column(
            modifier = Modifier
                .background(Color.White)
                .width(100.dp)
        ) {
            AutoScrollText(
                text = "abcdefghijklmnopqrstuvwxyz",
                autoScrollType = AutoScrollType.Duration(3000, 500),
                startVisualize = true,
                modifier = Modifier
            )
            AutoScrollText(
                text = "abcdefghijklmnopqrstuvwxyz",
                autoScrollType = AutoScrollType.Duration(3000),
                startVisualize = false
            )
            AutoScrollText(
                text = "abcdefghijklmnopqrstuvwxyz",
                autoScrollType = AutoScrollType.PerCharacterLength(20),
                startVisualize = true
            )
            AutoScrollText(
                text = "abcdefghijklmnopqrstuvwxyz",
                autoScrollType = AutoScrollType.PerCharacterLength(10),
                startVisualize = false
            )
        }
    }
}
```
![](https://storage.googleapis.com/zenn-user-upload/d5dcc17d6d37-20241125.gif =600x)
`gray`ã®éƒ¨åˆ†ãŒcomposableå¤–ã®æƒ³å®šã§ã€`white`ãŒè¦ªLayoutã®è¡¨ç¤ºç¯„å›²ã€‚
ã“ã‚Œã§ã¯ä»–ã®composableã¨çµ„ã¿åˆã‚ã›ã¦ä½¿ã†æ™‚ã«ä¸ä¾¿

---

ã“ã‚Œã‚’textã®è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ç¯„å›²ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—ã—ã¦ã€ãã‚Œä»¥å¤–ã¯`Color.Transparent`ã§ä¸Šæ›¸ãã™ã‚‹ã€‚

```kotlin
@Composable
fun AutoScrollText(
    modifier: Modifier = Modifier,
    text: String,
    style: TextStyle = LocalTextStyle.current,
    autoScrollType: AutoScrollType = AutoScrollType.Duration(5000),
    startVisualize: Boolean = true,
) {

    val textWidth = remember { mutableIntStateOf(0) }
    val layoutWidth = remember { mutableIntStateOf(0) }

    val transitionWidth =
        if (startVisualize) textWidth.intValue - layoutWidth.intValue
        else textWidth.intValue

    val animatedOffsetX = remember { Animatable(0f) }

    val visibleCharRange = remember(text) { mutableStateOf(text.indices) }

    LaunchedEffect(transitionWidth) {
        while (
            // layoutã‚µã‚¤ã‚ºã«åã¾ã£ã¦ã„ã‚Œã°ä½•ã‚‚ã—ãªã„
            transitionWidth > 0
        ) {
            animatedOffsetX.snapTo(if (startVisualize)  0f else layoutWidth.intValue.toFloat())
            delay(autoScrollType.delayMillis)
            animatedOffsetX.animateTo(
                targetValue = -transitionWidth.toFloat(),
                animationSpec = tween(
                    durationMillis = when (autoScrollType) {
                        is AutoScrollType.Duration -> autoScrollType.millis
                        is AutoScrollType.PerCharacterLength -> transitionWidth * autoScrollType.millis
                    }.toInt(),
                    easing = LinearEasing,
                )
            )
            delay(autoScrollType.delayMillis)
        }
    }

    LaunchedEffect(Unit) {
        // 1æ–‡å­—ã‚ãŸã‚Šã®å¹…
        val charWidth = textWidth.intValue / text.length.toFloat()
        snapshotFlow {
            animatedOffsetX.value
        }.collect {
            // ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚ªãƒ•ã‚»ãƒƒãƒˆã«åŸºã¥ãé–‹å§‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨çµ‚äº†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
            val startIndex = ceil(-animatedOffsetX.value / charWidth).toInt()
            val visibleSize = floor(layoutWidth.intValue / charWidth).toInt()
            val endIndex = minOf(startIndex + visibleSize, text.length)

            // è¡¨ç¤ºä¸­ã®æ–‡å­—ç¯„å›²ã‚’æ›´æ–°
            visibleCharRange.value = startIndex until endIndex
        }
    }

    Layout(
        modifier = modifier,
        content = {
            Text(
                text = buildAnnotatedString {
                    text.forEachIndexed { index, c ->
                        if (visibleCharRange.value.contains(index)) {
                            append(c)
                        } else {
                            // è¡¨ç¤ºç¯„å›²ã§ãªã‘ã‚Œã°é€éè‰²ã«ã™ã‚‹
                            withStyle(style = SpanStyle(color = Color.Transparent)) {
                                append(c)
                            }
                        }
                    }
                }
                ,
                style = style,
                maxLines = 1,
                overflow = TextOverflow.Clip,
            )
        },
        measurePolicy = { measurable, constraints ->
            val textMeasurable = measurable.first()

            layoutWidth.intValue = constraints.maxWidth

            val placeable = textMeasurable.measure(
                // layoutã®ã‚µã‚¤ã‚ºã«é–¢ã‚ã‚‰ãšå…¨ã¦ã‚’è¡¨ç¤ºã™ã‚‹
                constraints.copy(maxWidth = Int.MAX_VALUE)
            )
            // textã®ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹
            textWidth.intValue = placeable.width

            layout(layoutWidth.intValue, placeable.height) {
                placeable.place(animatedOffsetX.value.toInt(), 0)
            }
        }
    )
}
```

çµæœâ†“
![](https://storage.googleapis.com/zenn-user-upload/7004058c1f13-20241125.gif =600x)

ã„ã„æ„Ÿã˜ã«éè¡¨ç¤ºï¼Ÿã«å‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã‚‹